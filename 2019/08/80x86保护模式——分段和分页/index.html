<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="[x] 什么是逻辑地址？ 虚拟地址&#x3D;&#x3D;逻辑地址。是程序由段选择符+段内偏移组成的地址。逻辑地址选哟分段地址的变化处理之后才能得到相应的物理内存地址。   [ ] 书中提到的 分段提供了代码、数据的隔离，是否可以理解为 在IDA看到的，整个线性的结构，其实代码和数据被加载到了不同的段中？ 说来话长。    80x86保护模式及其编程  保护模式内存寻址  什么是保护模式 和 实模式？ 个人的简单">
<meta property="og:type" content="article">
<meta property="og:title" content="【Linux 0.12】80x86保护模式——分段和分页">
<meta property="og:url" content="https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/index.html">
<meta property="og:site_name" content="Amjac 的博客">
<meta property="og:description" content="[x] 什么是逻辑地址？ 虚拟地址&#x3D;&#x3D;逻辑地址。是程序由段选择符+段内偏移组成的地址。逻辑地址选哟分段地址的变化处理之后才能得到相应的物理内存地址。   [ ] 书中提到的 分段提供了代码、数据的隔离，是否可以理解为 在IDA看到的，整个线性的结构，其实代码和数据被加载到了不同的段中？ 说来话长。    80x86保护模式及其编程  保护模式内存寻址  什么是保护模式 和 实模式？ 个人的简单">
<meta property="og:locale" content="zh_CH">
<meta property="og:image" content="https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/69615107849e274a020881c3.jpg">
<meta property="og:image" content="https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/1564636249778.png">
<meta property="og:image" content="https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/201908011511DHCG8.png">
<meta property="og:image" content="https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/20080115_cbbab26241c63c1fdb5e9nKfEur4o24k.jpg">
<meta property="og:image" content="https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/69615107849e274a020881c3.jpg">
<meta property="og:image" content="https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/8a38ccdfbf9ea16594ee37c8.jpg">
<meta property="og:image" content="https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/20160109212505876">
<meta property="og:image" content="https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/20160112224111149">
<meta property="og:image" content="https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/20160109220126301">
<meta property="og:image" content="https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/825979-20180526004627172-1439403353.png">
<meta property="og:image" content="https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/825979-20180130231418296-652550151.png">
<meta property="og:image" content="https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/1564818974458.png">
<meta property="og:image" content="https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/123826422.jpg">
<meta property="article:published_time" content="2019-08-01T06:55:02.000Z">
<meta property="article:modified_time" content="2021-06-30T09:15:20.088Z">
<meta property="article:author" content="Amjac">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/69615107849e274a020881c3.jpg">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>【Linux 0.12】80x86保护模式——分段和分页</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" "Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">主页</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/archives/">归档</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post " href="/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post " href="/2019/07/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%8C%87%E4%BB%A4/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top " href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post " href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/&text=【Linux 0.12】80x86保护模式——分段和分页"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/&title=【Linux 0.12】80x86保护模式——分段和分页"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/&is_video=false&description=【Linux 0.12】80x86保护模式——分段和分页"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=【Linux 0.12】80x86保护模式——分段和分页&body=Check out this article: https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/&title=【Linux 0.12】80x86保护模式——分段和分页"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/&title=【Linux 0.12】80x86保护模式——分段和分页"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/&title=【Linux 0.12】80x86保护模式——分段和分页"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/&title=【Linux 0.12】80x86保护模式——分段和分页"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/&name=【Linux 0.12】80x86保护模式——分段和分页&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/&t=【Linux 0.12】80x86保护模式——分段和分页"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B6%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text"> 80x86保护模式及其编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80"><span class="toc-number">1.1.</span> <span class="toc-text"> 保护模式内存寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 内存寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 地址变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.2.1.</span> <span class="toc-text"> 分段机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.2.2.</span> <span class="toc-text"> 分页机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.1.3.1.</span> <span class="toc-text"> 任务之间的保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.1.3.2.</span> <span class="toc-text"> 特权级保护</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6-2"><span class="toc-number">1.2.</span> <span class="toc-text"> 分段机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 段的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A6"><span class="toc-number">1.2.1.1.</span> <span class="toc-text"> 段选择符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="toc-number">1.2.1.2.</span> <span class="toc-text"> 段描述符表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.2.1.3.</span> <span class="toc-text"> 段描述符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%92%8C%E6%95%B0%E6%8D%AE%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 代码和数据段描述符类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text"> 系统段描述符类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6-2"><span class="toc-number">1.3.</span> <span class="toc-text"> 分页机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 页表结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.1.</span> <span class="toc-text"> 二级页表结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 页表项结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 虚拟存储</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        【Linux 0.12】80x86保护模式——分段和分页
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Amjac</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-08-01T06:55:02.000Z" itemprop="datePublished">2019-08-01</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Linux%E5%AD%A6%E4%B9%A0/">Linux学习</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Linux/" rel="tag">Linux</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <ul>
<li>
<p>[x] 什么是逻辑地址？</p>
<p>虚拟地址==逻辑地址。是程序由段选择符+段内偏移组成的地址。逻辑地址选哟分段地址的变化处理之后才能得到相应的物理内存地址。</p>
</li>
<li>
<p>[ ] 书中提到的 分段提供了代码、数据的隔离，是否可以理解为 在IDA看到的，整个线性的结构，其实代码和数据被加载到了不同的段中？</p>
<p>说来话长。</p>
</li>
</ul>
<h1 id="80x86保护模式及其编程"><a class="markdownIt-Anchor" href="#80x86保护模式及其编程"></a> 80x86保护模式及其编程</h1>
<h2 id="保护模式内存寻址"><a class="markdownIt-Anchor" href="#保护模式内存寻址"></a> 保护模式内存寻址</h2>
<blockquote>
<p>什么是保护模式 和 实模式？</p>
<p>个人的简单理解：实模式使用的是真实的物理地址，20位地址线。</p>
<p>地址保护模式，使得处理器能够对内存以及其他外设做 <strong>硬件级别的保护设置</strong>。在保护模式下，程序员指定逻辑地址，用16位段寄存器和32位寄存器来表示。但此时段寄存器保存的值不再是段基址，而是一个Selector（段选择符）。操作系统根据Selector的值来算出段基地址，再和偏移地址相加得到实际的物理地址。</p>
<p>8086中有4个16bit的段寄存器 CS DS SS ES，保存的是段基地址</p>
<p>80386中，有6个16bit的段寄存，增加了FS，GS，不再存放段基地址，而是存放<strong>段选择符</strong>，因为16bit寄存器无法存放32位的段基地址。段基地址保存在描述符表中（Description Table），比如GDT和LDT。GDTR和LDTR就是保存GDT和LDT的地址和大小。</p>
</blockquote>
<h3 id="内存寻址"><a class="markdownIt-Anchor" href="#内存寻址"></a> 内存寻址</h3>
<p>80x86 CPU 是小端序处理器。（Of Course.）</p>
<p>为了实现内存寻址，80x86 使用了一种称为段（Segment）的寻址技术。该技术把内存空间分割成一个或多个称为段的线性区域，从而对内存中一个数据对象的寻址就需要使用一个段的<strong>起始地址</strong> + <strong>段内偏移</strong>。</p>
<p>段地址使用16bit段选择符指定，其中14bit可以选择2^14=16384个段。</p>
<p><img src="/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/69615107849e274a020881c3.jpg" alt="img"></p>
<p>段内偏移为32bit，因此段内地址可以是0~4GB。</p>
<p>16bit的段+32bit的偏移构成了48bit的地址，或称长指针，称为<strong>逻辑地址/虚拟地址</strong></p>
<p>80x86为段部分提供了6个存放段选择符的段寄存器：CS，DS，ES，SS，FS，GS。其中CS总用于寻址代码段，SS总用于堆栈段。EIP寄存器包含当前代码段下一条要执行指令的<strong>段内偏移地址</strong>，所以下一条指令的地址可以表示为 CS:[EIP]。</p>
<p>同理，SS:[ESP] 指向栈顶。</p>
<p>当指令中没有指令操作数据的段时，默认使用DS段。</p>
<h3 id="地址变换"><a class="markdownIt-Anchor" href="#地址变换"></a> 地址变换</h3>
<p>保护措施（保护模式）可以防止一个任务访问另一个任务或者操作系统的内存区域。而地址变换使得操作系统在给任务分配内存时更具有灵活性。同时由于我们可以让某些物理地址不被任何逻辑地址映射，所以在地址变换的过程中同时也提供了内存保护功能。</p>
<p>计算机物理内存是字节的线性数组，每个字节具有唯一的物理地址。</p>
<p>程序中的地址是由两部分构成的逻辑地址，这种逻辑地址并不能直接用于访问物理内存，而需要使用<strong>地址变换机制</strong>将其映射到物理内存上。内存管理机制用于此。</p>
<p><img src="/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/1564636249778.png" alt="1564636249778"></p>
<blockquote>
<p>所以什么是线性地址？</p>
<p>总的来说，虚拟地址指的是 [段描述符]:段内偏移，即进行段式转换之前的地址。那么线性地址就是段式转换之后，页式转换之前的地址。</p>
</blockquote>
<p>分段机制提供了隔绝各个代码、数据、堆栈区域的机制，因此多个程序可以在同一个处理器上而不被干扰。</p>
<p>分页机制为传统需求页、虚拟内存系统提供了实现机制。其中虚拟内存系统用于实现程序代码按要求被映射到物理内存中。</p>
<h4 id="分段机制"><a class="markdownIt-Anchor" href="#分段机制"></a> 分段机制</h4>
<p>分段可以**将处理器能寻址的线性地址空间 划分为一些较小的，称为段的受保护地址空间区域。**段可以用于存放程序的代码、数据、和堆栈，或者用于存放系统数据结构（TSS，LDT）。如果处理器中有多个程序或者任务正在运行，那么每个程序可以分配各自的一套段。此时处理器就可以加强这些段之间的界限，并确保一个程序不会通过访问另一个程序的段来干扰它的运行。分段机制还允许对段进行分类，特定类型的段操作会受到限制。</p>
<p>一个系统<strong>所有的段都包含在处理器线性地址中</strong>。为了定位指定段中的一个字节，程序必须提供一个逻辑地址（逻辑地址包括一个段选择符和一个偏移量）。通过段选择符，在段描述符表（比如GDT，LDT）中找到一个数据结构（即段描述符）。段描述符指明段的大小、访问权限、特权级、段类型、段的基地址等。逻辑地址的偏移部分加到段的基地址上就形成了线性地址。</p>
<h4 id="分页机制"><a class="markdownIt-Anchor" href="#分页机制"></a> 分页机制</h4>
<p>多任务系统通常定义的线性地址空间都比其物理内存空间大很多，所以需要使用某种虚拟化线性地址空间的方法（这不是骗子吗）。该技术可以让程序员制作大型程序时无需考虑物理内存的容量。</p>
<p>分页机制支持虚拟存储技术。大容量的线性地址空间需要使用小块的物理内存（RAM，ROM）以及某些外部存储空间（如硬盘）来模拟。当使用分页时，每个段被划分为页面（一般4K），操作系统维护一个页目录，还有页表。当程序访问线性地址空间时，处理器用页目录和页表将线性地址转换成一个物理地址。</p>
<p>（如果访问的页不在内存中，则引发缺页中断，将该页读入内存。该机制用到了页面交换。）</p>
<p><img src="/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/201908011511DHCG8.png" alt="img"></p>
<h3 id="保护"><a class="markdownIt-Anchor" href="#保护"></a> 保护</h3>
<p>80x86 提供两种保护。</p>
<ol>
<li>给每个任务不同的虚拟地址空间，完全隔离各个任务。</li>
<li>对任务进行操作，以保护操作系统内存段和处理器特殊系统寄存器不被应用程序访问。</li>
</ol>
<h4 id="任务之间的保护"><a class="markdownIt-Anchor" href="#任务之间的保护"></a> 任务之间的保护</h4>
<p>每个任务都有自己的段表和页表，从而完全隔离虚拟地址。</p>
<p>通过在所有任务中安排具有相同的虚拟到物理地址映射部分，并把操作系统存储在这个公共的虚拟地址空间部分，操作系统可以被所有的任务共享。这个所有的任务都具有的相同的虚拟地址空间部分被称为全局地址空间（Global Address Space）。</p>
<p>每个任务唯一的地址空间部分被称为局部地址空间（Local Address Space）。局部地址空间含有需要与系统中其他任务区别开的私有的代码和数据。由于每个任务中具有不同的局部地址空间，因此两个不同任务中对相同虚拟地址处的引用将转换到不同的物理地址处。这使得操作系统可以给予每个任务内存相同的虚拟地址，但仍然能隔绝每个任务。</p>
<h4 id="特权级保护"><a class="markdownIt-Anchor" href="#特权级保护"></a> 特权级保护</h4>
<p>一个任务中定义了4个特权级（Privilege Level 0~3），用于依据段中含有数据的敏感度以及任务中不同程序部分的受信程度。</p>
<p><strong>每个内存段都和一个特权级相关</strong>。特权级限制具有足够特权级的程序来访问这个段。CPL表示当前程序的特权级。</p>
<p>每个特权级都有自己的程序栈，避免共享栈带来的保护问题。当程序从一个特权级切换到另一个特权级执行时，堆栈段也随之改变。</p>
<h2 id="分段机制-2"><a class="markdownIt-Anchor" href="#分段机制-2"></a> 分段机制</h2>
<h3 id="段的定义"><a class="markdownIt-Anchor" href="#段的定义"></a> 段的定义</h3>
<p>每个段由以下参数定义：</p>
<ol>
<li>段基地址：段在线性地址空间的起始地址</li>
<li>段限长：段内最大可用偏移位置</li>
<li>段属性：该段是否可读可写可执行，特权级等。</li>
</ol>
<p>这些属性保存在一个称为<strong>段描述符</strong>（Segment Descriptor）的结构体中。段描述符保存在<strong>段描述符表</strong>（Descriptor Table），是一个简单数组。</p>
<p>逻辑地址由16bit<strong>段选择符</strong>和32bit偏移组成。逻辑地址向线性地址的转换过程如下。</p>
<p><img src="/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/20080115_cbbab26241c63c1fdb5e9nKfEur4o24k.jpg" alt="Snap3.jpg"></p>
<p>如果没有开启分页，则处理器直接将线性地址映射到物理地址。</p>
<h4 id="段选择符"><a class="markdownIt-Anchor" href="#段选择符"></a> 段选择符</h4>
<p>在保护模式下，段寄存器存放的就是段选择符</p>
<p><img src="/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/69615107849e274a020881c3.jpg" alt="img"></p>
<ul>
<li>RPL：请求特权级（Requested Privilege Level）</li>
<li>TI：表指示标志（Table Index）。TI=0表示位于GDT，TI=1表示位于LDT。</li>
</ul>
<p>有六个段寄存器（CS, DS, SS, ES, FS, GS）用于保存段描述符。</p>
<p>对于访问某个段的程序，必须已经把段选择符加载到一个段寄存器中。因此尽管一个系统可以定义很多的段，但同时只有6个段可供立即访问。</p>
<p>此外，为了避免访问内存时每次都去引用描述符表来解码一个段描述符，每个段寄存器都有一个“可见部分” 和一个 “隐藏部分”。隐藏部分也被称为<strong>描述符缓冲</strong>。当一个段选择符被加载到一个段寄存器的可见部分中时，处理器也将段描述符中的段地址、段限长、以及访问控制信息加载到段寄存器的隐藏部分中。</p>
<p>缓冲在段寄存器中的信息使得处理器可以在进行地址转换时不再需要花费时间从段描述符中读取基地址和限长。</p>
<p>由于描述符缓冲保存了描述符信息的一个副本，所以操作系统必须确保对描述符表的改动反应到描述符缓冲上。最便捷的方法是在对描述符表的操作符经过任何改动后，立刻重新加载6个段寄存器。</p>
<h4 id="段描述符表"><a class="markdownIt-Anchor" href="#段描述符表"></a> 段描述符表</h4>
<p>段描述符表是段描述符组成的的数组，最多可以包含 2^(16-3)=8192个项，每个段描述符8Byte。</p>
<p>段描述符表有两种：</p>
<ol>
<li>GDT：全局描述符表</li>
<li>LDT：局部描述符表</li>
</ol>
<p><img src="/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/8a38ccdfbf9ea16594ee37c8.jpg" alt="img"></p>
<p>描述符表保存于操作系统维护的特殊数据结构中，且由处理器的内存管理硬件来引用。这些特殊结构应该保存在仅由操作系统软件访问的受保护内存区域中，以防止应用层修改其地址转换信息。</p>
<p>虚拟空间被分割为大小相等的两半，一半由GDT来映射，另一半由LDT映射。整个虚拟地址空间包含2^14个段（2 * 2^13）。GDT负责映射全局虚拟地址空间，LDT负责映射局部虚拟地址空间。即：GDT映射的区域是所有任务共享的。</p>
<p>当发生任务切换时，LDT会更换成新任务的LDT，但是GDT不会改变。</p>
<p>每个系统必须定义一个GDT，可选定义多个LDT，比如可以为每个任务定义一个LDT，也可以让一些任务共享一个LDT。</p>
<p>GDT本身是线性地址空间的一个数据结构。GDT的线性基地址和长度必须保存到GDTR中。GDT的基地址应该进行内存8Byte对齐，以得到最佳的处理器性能，因为段描述符总是8Byte。</p>
<p>LDT存放在LDT类型的系统段中。此时GDT必须含有LDT的段描述符。如果系统支持多LDT的话，每个LDT都必须在GDT中有一个段描述符和段选择符。</p>
<p>访问LDT时为了减少地址转换的次数，LDT的段选择符、基地址等信息需要存放在LDTR寄存器中。</p>
<h4 id="段描述符"><a class="markdownIt-Anchor" href="#段描述符"></a> 段描述符</h4>
<p>每个段描述符都是GDT和LDT的一项。</p>
<p>每个段描述符8Byte，包含三个主要字段：段基地址，段限长，段属性</p>
<p>段描述符一般由编译器，连接器，加载器，或者操作系统创建，但绝不是应用程序。段描述符的通用格式如下：</p>
<p><img src="/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/20160109212505876" alt="段描述符通用格式"></p>
<p>解释各字段：</p>
<ol>
<li>
<p>段限长 Segment Limit: 指定段的长度。处理器会把两个段限长字段组合成一个20bit的值，并根据颗粒度G来指定值的实际含义。如果G=0，则Limit为1B<sub>1MB，单位是1B。如果G=1，则Limit为4KB</sub>4GB，单位是4K。</p>
<p>E为段扩展方向标志（？？是不是TYPE??）。处理器以两种不同方式使用段限长Limit。对于上扩展的段（简称上扩段），逻辑地址中的便宜范围可以从0~段长limit。大于段限长limit的偏移将产生一般保护性异常。对于向下扩展的段，段限长的含义则相反。根据默认栈指针指针大小标志B的设置，偏移范围可以从段限长到0xFFFFFFFF或者0xFFFF，而小于段限长的偏移值则会引起一般保护性异常。对于下扩段，减小段限长字段的值会为在该段地址空间的底部分配新的内存，而不是在顶部分配。80x86的栈总是向下扩展的，因此该方式适合扩展堆栈。</p>
<blockquote>
<p>上文中，默认高地址在上，低地址在下。</p>
</blockquote>
</li>
<li>
<p>基地址字段 Base: 把三个分离的基地址字段组合形成一个32位的值。</p>
</li>
<li>
<p>段类型字段 Type：用行指定段或门（Gate）的类型，说明段的访问种类以及扩展方向。该字段的解释依赖于描述符类型标志S，指明时一个应用（代码或数据）描述符，还是系统描述符。不同的S对应的TYPE字段的解释都不同。</p>
<p><img src="/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/20160112224111149" alt="数据段和代码段描述符"></p>
</li>
<li>
<p>描述符类型标志 S：指明一个段描述符时系统段描述符（S=0）还是数据代码段描述符（S=1）</p>
</li>
<li>
<p>描述符特权级字段DPL：用于指明描述符的特权级。0~3</p>
</li>
<li>
<p>段存在标志P：表示段在内存中（P=1）还是不在内存中（P=0）。当段描述符的P标志位0时，把指向这个段描述符的选择符加载到段寄存器将导致产生一个段不存在异常。内存管理软件可以使用这个标志来控制在某一给定时间实际需要把哪个段加载到内存。该功能为虚拟存储提供了除了分页机机制以外的控制。</p>
</li>
<li>
<p>D/B 默认操作大小/默认指针大小和/或上界限 标志。根据段描述符描述的实一个可执行代码段、下扩数据段还是一个堆栈段，该标志有不同的功能。（对32位代码和数据段，该标志总为1；对于16位代码和数据段，标志置为0.）</p>
</li>
<li>
<p>颗粒度标志G：确定Limit值的单位。</p>
</li>
</ol>
<h3 id="代码和数据段描述符类型"><a class="markdownIt-Anchor" href="#代码和数据段描述符类型"></a> 代码和数据段描述符类型</h3>
<p>若段描述符的S字段为1，则该描述符用于代码或者数据段。此时类型字符Type的最高位用于确定是数据段描述符（置为0）还是代码段描述符（置为1）</p>
<p>对于数据段描述符，Type的低3bit用于表示已访问（Accessed），可写（Write-enable）和扩展方向E（Expansion-direction）。</p>
<p>其中，堆栈段必须是可读写的数据段。如果使用不可写数据段的选择符加载到SS寄存器中，将导致一个一般保护异常。如果堆栈段的长度需要动态地改变，那么堆栈段可以是一个向下扩展的数据段。标志位A一般用于调试。</p>
<p>对于代码段，TYPE字段解释为 A，R（可读），C（conforming 一致性）。</p>
<blockquote>
<p>一致性：高权限不允许访问低权限，低权限可以访问高权限，但特权级不改变。</p>
<p>非一致性：只允许同级别之间访问</p>
</blockquote>
<p>所有的数据段都是非一致的，但数据段可以被高特权级访问（高——&gt;低）。</p>
<p><img src="/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/20160109220126301" alt="代码段和数据段描述符类型"></p>
<h3 id="系统段描述符类型"><a class="markdownIt-Anchor" href="#系统段描述符类型"></a> 系统段描述符类型</h3>
<p>系统描述符如下：第12bit=1</p>
<p><img src="/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/825979-20180526004627172-1439403353.png" alt="系统描述符"></p>
<p>处理器能够识别以下类型的系统段描述符，分两大类：系统段描述符，门描述符。</p>
<ul>
<li>局部描述符表（LDT）的段描述符</li>
<li>任务状态段（TSS）描述符</li>
<li>调用门描述符</li>
<li>中断门描述符</li>
<li>陷阱门描述符</li>
<li>任务门描述符</li>
</ul>
<h2 id="分页机制-2"><a class="markdownIt-Anchor" href="#分页机制-2"></a> 分页机制</h2>
<p>在分段机制的基础上完成虚拟地址到物理地址的转换过程。</p>
<p>处理器分页机制会把线性地址空间划分为页面，然后这些线性地址空间页面被映射到物理地址空间页面上。</p>
<p>通过设置控制寄存器CR0的PG位可以选择启用分页机制。</p>
<p>分页机制对固定大小的内存块进行操作（称为页面）。分页机制把线性和物理空间都划分成页面，线性地址空间中的任何页面都可以被映射到物理地址空间的任何页面上，并在两个空间之间提供任意映射。</p>
<p><img src="/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/825979-20180130231418296-652550151.png" alt="线性地址空间页面到物理地址空间页面对应示意图"></p>
<p>80x86以4K作为固定页面大小。每个页面对齐于4K地址边界处。这表示分页机制把2<sup>32B（4G）的线性地址空间划分为了2</sup>20个页面。<strong>分页机制通过把线性地址空间中的页面重新定位到物理地址空间中进行操作</strong>。由于4K大小的页面，因此线性地址的低12bit可以作为页内偏移，<strong>直接作为物理地址的低12bit</strong>。分页机制的重定位功能可以看作替换高20bit。</p>
<p>线性地址到物理地址的转换功能被扩展为允许一个线性地址被标注为无效的，而非让其产生一个物理地址。在两种情况下一个页面可以被注册为无效：</p>
<ol>
<li>操作系统不支持的线性地址：此时产生无效地址的程序必须终止。</li>
<li>对应在虚拟地址：该无效地址实际上时请求操作系统虚拟内存管理器将对应的页面从磁盘上加载到物理内存，供程序访问。因为无效页面通常和虚拟存储系统相关，因此他们被称为不存在对于额面，并由页表中称为存在（present）的属性确定。</li>
</ol>
<p>在保护模式中，80x86允许线性地址空间直接映射大容量的物理内存，或者使用分页间接映射到较小容量的物理内存和磁盘存储空间中。这后一种映射线性地址的方法称为虚拟存储或者需求页虚拟存储。</p>
<p><strong>如果包含线性地址的页面目前不再物理内存中，处理器就会产生一个页错误异常，页错误异常处理程序会让操作系统从磁盘中把相应页面加载到物理内存中</strong>（操作过程中可能还会把物理内存中不同的页面写到磁盘上）。当页面加载到物理内存之后，从异常处理过程的返回操作会使得导致异常的指令重新执行。处理器用于将线性地址转换为物理地址使用的信息保存在<strong>页目录</strong>和<strong>页表</strong>中。</p>
<p>为了减少转换的开销，最近访问的页目录和页表会存放在缓冲器件中。该缓冲器件称为转换查找缓冲区（Translation Lookaside Buffer）。TLB可以满足大多数读页目录和页表的请求而无需使用总线周期。只有当TLB不包含要求的页表项时才会使用额外的总线周期从内存读取页表项。</p>
<h3 id="页表结构"><a class="markdownIt-Anchor" href="#页表结构"></a> 页表结构</h3>
<p>页表保存于内存，位于物理地址空间。页表可以看作简单的2^20个物理地址数组。线性到物理地址的映射功能可以简单地看作进行数组查找，线性地址的高20bit构成数组的索引值用于选择对应页面的物理（基）地址。</p>
<p>页表中每个表项大小为32bit。其中20bit用于保存物理基地址（4K对齐），剩余的12bit用于保存属性信息等。</p>
<h4 id="二级页表结构"><a class="markdownIt-Anchor" href="#二级页表结构"></a> 二级页表结构</h4>
<p>页表含有 2^20（1M）个表项，每项4B，。如果用一个表来保存，最多占用4MB的内存。</p>
<p>为了减少内存的占用量，80x86使用了二级表。高20bit线性地址到物理地址的变换通过两部进行，每步转换10bit。</p>
<p>第一级表称为<strong>页目录</strong>，存放在一个页面中（4K），具有2^10（1K）个4B长度的表项。这些表项指向对应的二级表。线性地址的最高10bit（位31~22）用作一级表/页目录的索引。</p>
<p>第二级表称为<strong>页表</strong>，长度也是一个页面（4K），最多含有1K个4B的表项。</p>
<p>下图给出查找过程。其中CR3寄存器指定页目录表的基地址。</p>
<blockquote>
<p>CR3 存放<strong>页目录表</strong>页面的<strong>物理地址</strong>，因此也被称为PDBR。由于页目录表页面时页对齐的，所以该寄存器只有高20位是有效的。而低12位保留供高级处理器使用。</p>
</blockquote>
<p><img src="/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/1564818974458.png" alt="线性地址和物理地址之间的变换"></p>
<p>然而。问题似乎并没有解决：页表还是需要4MB的空间，并没有减小啊。这反而又引入了页目录，不是更占空间吗？</p>
<p>然而，引入页目录虽然没有解决空间问题，但是允许页表被分散在内存的各个页面，而不必保存在一段连续的空间了（这样有意义吗？你问我我问谁）。此外，并不需要为不存在的，或者线性地址空间未使用的部分分配二级页表。虽然目录表页面总是必须存在于物理内存，但二级页表可以需要时再分配。</p>
<h3 id="页表项结构"><a class="markdownIt-Anchor" href="#页表项结构"></a> 页表项结构</h3>
<p><img src="/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/123826422.jpg" alt="页目录和页表的表项格式"></p>
<p>其中位31~12表示物理地址的高20bit，低12bit 含有页属性信息</p>
<ul>
<li>存在标志P（Present）：指明表项对地址转换是否有效。如果P=0，则其余位可以供程序自由使用。如图b所示。</li>
<li>读写标志R/W：如果=1，表明可读写执行；如果为0，表示只读或可执行。处理器运行于特权级（0,1,2）时，R/W位不起作用。页目录项的R/W对所有页起作用</li>
<li>用户/超级用户标志U/S：=1，则任何特权级程序都能访问；=0，则只有超级用户特权级才能访问。</li>
<li>已访问标志A：处理器访问页表项映射的页面时，页目录表项的该标志置为1。处理器只负责设置，操作系统可以通过定期复位，来统计页面的使用情况。</li>
<li>修改标志D(dirty)：处理器对一个页面执行写操作时会设置。页目录项的D标志不会被修改。</li>
<li>AVL：保留字段，专供程序使用。</li>
</ul>
<h3 id="虚拟存储"><a class="markdownIt-Anchor" href="#虚拟存储"></a> 虚拟存储</h3>
<p>页目录和页表表项中的存在标志P为使用分页技术的虚拟存储提供了必要支持。若线性地址空间中的页面存在于物理内存中，则P=1，且该表项中含有相应物理地址。如果页面不在物理内存，则P=0，程序访问物理内存不存在的页面就会产生缺页异常，操作系统可以利用该异常处理过程，将缺少的页面从磁盘调入物理内存。</p>
<p>标志A和D可以用于实现虚拟存储技术。通过周期性地检查和复位A标志，操作系统能确定哪些页面最近没有访问过，这些页面可以成为移出到磁盘的候选者。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">主页</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/archives/">归档</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%85%B6%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text"> 80x86保护模式及其编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80"><span class="toc-number">1.1.</span> <span class="toc-text"> 保护模式内存寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 内存寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 地址变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.2.1.</span> <span class="toc-text"> 分段机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.2.2.</span> <span class="toc-text"> 分页机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.1.3.1.</span> <span class="toc-text"> 任务之间的保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.1.3.2.</span> <span class="toc-text"> 特权级保护</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6-2"><span class="toc-number">1.2.</span> <span class="toc-text"> 分段机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 段的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E9%80%89%E6%8B%A9%E7%AC%A6"><span class="toc-number">1.2.1.1.</span> <span class="toc-text"> 段选择符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="toc-number">1.2.1.2.</span> <span class="toc-text"> 段描述符表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.2.1.3.</span> <span class="toc-text"> 段描述符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%92%8C%E6%95%B0%E6%8D%AE%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 代码和数据段描述符类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text"> 系统段描述符类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6-2"><span class="toc-number">1.3.</span> <span class="toc-text"> 分页机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 页表结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.1.</span> <span class="toc-text"> 二级页表结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 页表项结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 虚拟存储</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/&text=【Linux 0.12】80x86保护模式——分段和分页"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/&title=【Linux 0.12】80x86保护模式——分段和分页"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/&is_video=false&description=【Linux 0.12】80x86保护模式——分段和分页"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=【Linux 0.12】80x86保护模式——分段和分页&body=Check out this article: https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/&title=【Linux 0.12】80x86保护模式——分段和分页"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/&title=【Linux 0.12】80x86保护模式——分段和分页"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/&title=【Linux 0.12】80x86保护模式——分段和分页"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/&title=【Linux 0.12】80x86保护模式——分段和分页"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/&name=【Linux 0.12】80x86保护模式——分段和分页&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://iamjustachild.github.io/2019/08/80x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5/&t=【Linux 0.12】80x86保护模式——分段和分页"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2021
    Amjac
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">主页</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/archives/">归档</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
